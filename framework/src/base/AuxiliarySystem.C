/****************************************************************/
/*               DO NOT MODIFY THIS HEADER                      */
/* MOOSE - Multiphysics Object Oriented Simulation Environment  */
/*                                                              */
/*           (c) 2010 Battelle Energy Alliance, LLC             */
/*                   ALL RIGHTS RESERVED                        */
/*                                                              */
/*          Prepared by Battelle Energy Alliance, LLC           */
/*            Under Contract No. DE-AC07-05ID14517              */
/*            With the U. S. Department of Energy               */
/*                                                              */
/*            See COPYRIGHT for full restrictions               */
/****************************************************************/

#include "AuxiliarySystem.h"
#include "FEProblem.h"
#include "Factory.h"
#include "AuxKernel.h"
#include "AuxScalarKernel.h"
#include "MaterialData.h"
#include "Assembly.h"
#include "GeometricSearchData.h"
#include "ComputeNodalAuxVarsThread.h"
#include "ComputeNodalAuxBcsThread.h"
#include "ComputeElemAuxVarsThread.h"
#include "ComputeElemAuxBcsThread.h"
#include "Parser.h"

#include "libmesh/quadrature_gauss.h"
#include "libmesh/node_range.h"

// AuxiliarySystem ////////

AuxiliarySystem::AuxiliarySystem(FEProblem & subproblem, const std::string & name) :
    SystemTempl<TransientExplicitSystem>(subproblem, name, Moose::VAR_AUXILIARY),
    _mproblem(subproblem),
    _serialized_solution(*NumericVector<Number>::build().release()),
    _need_serialized_solution(false)
{
  _nodal_vars.resize(libMesh::n_threads());
  _elem_vars.resize(libMesh::n_threads());
}

AuxiliarySystem::~AuxiliarySystem()
{
  delete &_serialized_solution;
}

void
AuxiliarySystem::init()
{
  if (_need_serialized_solution)
    _serialized_solution.init(_sys.n_dofs(), false, SERIAL);
}

void
AuxiliarySystem::initialSetup()
{
  for(unsigned int i=0; i<libMesh::n_threads(); i++)
  {
    _auxs(EXEC_RESIDUAL)[i].initialSetup();
    _auxs(EXEC_TIMESTEP)[i].initialSetup();
    _auxs(EXEC_TIMESTEP_BEGIN)[i].initialSetup();
  }
}

void
AuxiliarySystem::timestepSetup()
{
  for(unsigned int i=0; i<libMesh::n_threads(); i++)
  {
    _auxs(EXEC_RESIDUAL)[i].timestepSetup();
    _auxs(EXEC_TIMESTEP)[i].timestepSetup();
    _auxs(EXEC_TIMESTEP_BEGIN)[i].timestepSetup();
  }
}

void
AuxiliarySystem::residualSetup()
{
  for(unsigned int i=0; i<libMesh::n_threads(); i++)
    _auxs(EXEC_RESIDUAL)[i].residualSetup();
}

void
AuxiliarySystem::jacobianSetup()
{
  for(unsigned int i=0; i<libMesh::n_threads(); i++)
    _auxs(EXEC_RESIDUAL)[i].jacobianSetup();
}

void
AuxiliarySystem::addVariable(const std::string & var_name, const FEType & type, Real scale_factor, const std::set< SubdomainID > * const active_subdomains/* = NULL*/)
{
  SystemTempl<TransientExplicitSystem>::addVariable(var_name, type, scale_factor, active_subdomains);
  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    MooseVariable * var = dynamic_cast<MooseVariable *>(_vars[tid].getVariable(var_name));
    if (var != NULL)
    {
      if (var->feType().family == LAGRANGE)
        _nodal_vars[tid][var_name] = var;
      else
        _elem_vars[tid][var_name] = var;
    }
  }
}

void
AuxiliarySystem::addKernel(const  std::string & kernel_name, const std::string & name, InputParameters parameters)
{
  parameters.set<AuxiliarySystem *>("_aux_sys") = this;
  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    parameters.set<THREAD_ID>("_tid") = tid;
    parameters.set<MaterialData *>("_material_data") = _mproblem._material_data[tid];

    AuxKernel *kernel = static_cast<AuxKernel *>(_factory.create(kernel_name, name, parameters));
    mooseAssert(kernel != NULL, "Not an AuxKernel object");

    std::set<SubdomainID> blk_ids;
    if (!parameters.isParamValid("block"))
      blk_ids = _var_map[kernel->variable().index()];
    else
    {
      std::vector<SubdomainName> blocks = parameters.get<std::vector<SubdomainName> >("block");
      for (unsigned int i=0; i<blocks.size(); ++i)
      {
        SubdomainID blk_id = _mesh.getSubdomainID(blocks[i]);

        if (_var_map[kernel->variable().index()].count(blk_id) > 0 || _var_map[kernel->variable().index()].size() == 0)
          blk_ids.insert(blk_id);
        else
          mooseError("AuxKernel (" + kernel->name() + "): block outside of the domain of the variable");
      }
    }

    _auxs(kernel->execFlag())[tid].addAuxKernel(kernel, blk_ids);
    _mproblem._objects_by_name[tid][name].push_back(kernel);
  }
}

void
AuxiliarySystem::addScalarKernel(const  std::string & kernel_name, const std::string & name, InputParameters parameters)
{
  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    parameters.set<THREAD_ID>("_tid") = tid;

    AuxScalarKernel *kernel = static_cast<AuxScalarKernel *>(_factory.create(kernel_name, name, parameters));
    mooseAssert(kernel != NULL, "Not a AuxScalarKernel object");

    _auxs(kernel->execFlag())[tid].addScalarKernel(kernel);
    _mproblem._objects_by_name[tid][name].push_back(kernel);
  }
}

void
AuxiliarySystem::addBoundaryCondition(const std::string & bc_name, const std::string & name, InputParameters parameters)
{
  parameters.set<AuxiliarySystem *>("_aux_sys") = this;
  std::vector<BoundaryName> boundaries = parameters.get<std::vector<BoundaryName> >("boundary");

  for (unsigned int i=0; i<boundaries.size(); ++i)
  {
    BoundaryID boundary = _mesh.getBoundaryID(boundaries[i]);
    parameters.set<BoundaryID>("_boundary_id") = boundary;

    for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
    {
      parameters.set<THREAD_ID>("_tid") = tid;
      parameters.set<MaterialData *>("_material_data") = _mproblem._bnd_material_data[tid];

      AuxKernel * bc = static_cast<AuxKernel *>(_factory.create(bc_name, name, parameters));
      mooseAssert(bc != NULL, "Not a AuxBoundaryCondition object");

      _auxs(bc->execFlag())[tid].addActiveBC(boundary, bc);
      _mproblem._objects_by_name[tid][name].push_back(bc);

      _vars[tid].addBoundaryVar(boundary, &bc->variable());
    }
  }
}

void
AuxiliarySystem::reinitElem(const Elem * /*elem*/, THREAD_ID tid)
{
  for (std::map<std::string, MooseVariable *>::iterator it = _nodal_vars[tid].begin(); it != _nodal_vars[tid].end(); ++it)
  {
    MooseVariable *var = it->second;
    var->computeElemValues();
  }

  for (std::map<std::string, MooseVariable *>::iterator it = _elem_vars[tid].begin(); it != _elem_vars[tid].end(); ++it)
  {
    MooseVariable *var = it->second;
    var->reinitAux();
    var->computeElemValues();
  }
}

void
AuxiliarySystem::reinitElemFace(const Elem * /*elem*/, unsigned int /*side*/, BoundaryID /*bnd_id*/, THREAD_ID tid)
{
  for (std::map<std::string, MooseVariable *>::iterator it = _nodal_vars[tid].begin(); it != _nodal_vars[tid].end(); ++it)
  {
    MooseVariable *var = it->second;
    var->computeElemValuesFace();
  }

  for (std::map<std::string, MooseVariable *>::iterator it = _elem_vars[tid].begin(); it != _elem_vars[tid].end(); ++it)
  {
    MooseVariable *var = it->second;
    var->reinitAux();
    var->reinitAuxNeighbor();
    var->computeElemValuesFace();
  }
}

NumericVector<Number> &
AuxiliarySystem::serializedSolution()
{
  _need_serialized_solution = true;
  return _serialized_solution;
}

void
AuxiliarySystem::serializeSolution()
{
  if (_need_serialized_solution && _sys.n_dofs() > 0)            // libMesh does not like serializing of empty vectors
    solution().localize(_serialized_solution);
}

void
AuxiliarySystem::compute(ExecFlagType type/* = EXEC_RESIDUAL*/)
{
  if (_vars[0].scalars().size() > 0)
  {
    computeScalarVars(_auxs(type));
    solution().close();
    _sys.update();
  }

  if (_vars[0].variables().size() > 0)
  {
    computeNodalVars(_auxs(type));
    solution().close();
    _sys.update();

    computeElementalVars(_auxs(type));
    solution().close();
    _sys.update();

    if (_need_serialized_solution)
      serializeSolution();
  }
}

std::set<std::string>
AuxiliarySystem::getDependObjects(ExecFlagType type)
{
  std::set<std::string> depend_objects;

  const std::vector<AuxKernel *> & auxs = _auxs(type)[0].all();
  for (std::vector<AuxKernel *>::const_iterator it = auxs.begin(); it != auxs.end(); ++it)
  {
    const std::set<std::string> & uo = (*it)->getDependObjects();
    depend_objects.insert(uo.begin(), uo.end());
  }
  return depend_objects;
}

NumericVector<Number> &
AuxiliarySystem::addVector(const std::string & vector_name, const bool project, const ParallelType type)
{
  if (hasVector(vector_name))
    return getVector(vector_name);

  NumericVector<Number> * vec = &_sys.add_vector(vector_name, project, type);

  return *vec;
}

void
AuxiliarySystem::computeScalarVars(std::vector<AuxWarehouse> & auxs)
{
  Moose::perf_log.push("update_aux_vars_scalar()","Solve");
  PARALLEL_TRY {
    // FIXME: run multi-threaded
    THREAD_ID tid = 0;
    if (auxs[tid].scalars().size() > 0)
    {
      _mproblem.reinitScalars(tid);

      const std::vector<AuxScalarKernel *> & scalars = auxs[tid].scalars();
      for (std::vector<AuxScalarKernel *>::const_iterator it = scalars.begin(); it != scalars.end(); ++it)
      {
        AuxScalarKernel * kernel = *it;
        kernel->compute();
      }

      const std::vector<MooseVariableScalar *> & scalar_vars = getScalarVariables(tid);
      for (std::vector<MooseVariableScalar *>::const_iterator it = scalar_vars.begin(); it != scalar_vars.end(); ++it)
      {
        MooseVariableScalar * var = *it;
        var->insert(solution());
      }
    }
  }
  PARALLEL_CATCH;
  Moose::perf_log.pop("update_aux_vars_scalar()","Solve");
}

void
AuxiliarySystem::computeNodalVars(std::vector<AuxWarehouse> & auxs)
{
  // Do we have some kernels to evaluate?
  bool have_block_kernels = false;
  for(std::set<SubdomainID>::const_iterator subdomain_it = _mesh.meshSubdomains().begin();
      subdomain_it != _mesh.meshSubdomains().end();
      ++subdomain_it)
  {
    have_block_kernels |= (auxs[0].activeBlockNodalKernels(*subdomain_it).size() > 0);
  }

  Moose::perf_log.push("update_aux_vars_nodal()","Solve");
  PARALLEL_TRY {
    if (auxs[0].activeNodalKernels().size() > 0 || have_block_kernels)
    {
      ConstNodeRange & range = *_mesh.getLocalNodeRange();
      ComputeNodalAuxVarsThread navt(_mproblem, *this, auxs);
      Threads::parallel_reduce(range, navt);
    }
  }
  PARALLEL_CATCH;
  Moose::perf_log.pop("update_aux_vars_nodal()","Solve");

  //Boundary AuxKernels
  Moose::perf_log.push("update_aux_vars_nodal_bcs()","Solve");
  PARALLEL_TRY {
    // after converting this into NodeRange, we can run it in parallel
    ConstBndNodeRange & bnd_nodes = *_mesh.getBoundaryNodeRange();
    ComputeNodalAuxBcsThread nabt(_mproblem, *this, auxs);
    Threads::parallel_reduce(bnd_nodes, nabt);
  }
  PARALLEL_CATCH;
  Moose::perf_log.pop("update_aux_vars_nodal_bcs()","Solve");
}

void
AuxiliarySystem::computeElementalVars(std::vector<AuxWarehouse> & auxs)
{
  Moose::perf_log.push("update_aux_vars_elemental()","Solve");
  PARALLEL_TRY {
    bool element_auxs_to_compute = false;

    for(unsigned int i=0; i<auxs.size(); i++)
      element_auxs_to_compute |= auxs[i].allElementKernels().size();

    if (element_auxs_to_compute)
    {
      ConstElemRange & range = *_mesh.getActiveLocalElementRange();
      ComputeElemAuxVarsThread eavt(_mproblem, *this, auxs);
      Threads::parallel_reduce(range, eavt);
    }

    bool bnd_auxs_to_compute = false;
    for(unsigned int i=0; i<auxs.size(); i++)
      bnd_auxs_to_compute |= auxs[i].allElementalBCs().size();
    if (bnd_auxs_to_compute)
    {
      ConstBndElemRange & bnd_elems = *_mesh.getBoundaryElementRange();
      ComputeElemAuxBcsThread eabt(_mproblem, *this, auxs);
      Threads::parallel_reduce(bnd_elems, eabt);
    }

  }
  PARALLEL_CATCH;
  Moose::perf_log.pop("update_aux_vars_elemental()","Solve");
}

void
AuxiliarySystem::augmentSparsity(SparsityPattern::Graph & /*sparsity*/,
                                 std::vector<unsigned int> & /*n_nz*/,
                                 std::vector<unsigned int> & /*n_oz*/)
{
}

Order
AuxiliarySystem::getMinQuadratureOrder()
{
  Order order = CONSTANT;
  std::vector<MooseVariable *> vars = _vars[0].variables();
  for (std::vector<MooseVariable *>::iterator it = vars.begin(); it != vars.end(); ++it)
  {
    if (!(*it)->isNodal()) // nodal aux variables do not need quadrature
    {
      FEType fe_type = (*it)->feType();
      if (fe_type.default_quadrature_order() > order)
        order = fe_type.default_quadrature_order();
    }
  }

  return order;
}
